<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>UHK Shipping progress</title>
    <style>
        html {
            height: 100%;
        }
        body {
            height: 100%;
            margin: 0;
        }
        #content {
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        #header {
            text-align: center;
        }
        #chart {
            flex: 1;
        }
        #footer {
            padding: 10px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- https://tholman.com/github-corners/ -->
    <a href="https://github.com/hxv/uhk-shipping-progress" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <div id="content">
        <div id="header">
            <h1>UHK Shipping progress</h1>
        </div>
        <div id="foo">
            <label for="myOrderNumber">My order number</label>
            <input type="number" id="myOrderNumber" placeholder="My order number" min="0">
            <br>
            <label for="type">Prediction type</label>
            <select id="type">
                <option value="none">No prediction</option>
                <option value="avg">Average</option>
                <option value="avg-optimistic">Average (skip empty)</option>
                <option value="max">Max</option>
                <option value="min">Min (skip empty)</option>
            </select>
            <br>
            <label for="historicalDataLimit">Base on last N updates</label>
            <input id="historicalDataLimit" type="number" value="0" min="0">
        </div>
        <div id="chart">
            <canvas id="shipping-chart"></canvas>
        </div>
        <div id="footer">
            <p>Join <a href="https://discord.gg/K869j4UYXa">unofficial UHK channel on Discord</a>!</p>
            <p>Also check out <a href="https://da11an.shinyapps.io/uhk_delivery_date/">UHK Delivery Status Predictor</a>.</p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@^3"></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@^2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@^1"></script>

    <script src="data.js"></script>
    <script src="main.js"></script>
    <script>
        const config = {
            type: 'line',
            options: {
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        ticks: {
                            source: 'labels',
                        },
                        offsetAfterAutoskip: true,
                        adapters: {
                            date: {
                                locale: window.navigator.language,
                            },
                        },
                    },
                },
                interaction: {
                    intersect: false,
                    mode: 'index',
                    axis: 'xy',
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            afterTitle: function (items) {
                                if (items[0] === undefined || items[1] === undefined) {
                                    return '';
                                }

                                return (Math.round(((items[0].raw - firstShippedOrder) / (items[1].raw - firstShippedOrder)) * 100 * 100) / 100) + '%';
                            },
                            afterLabel: function (item) {
                                let currentValue = item.raw;
                                let previousValue = item.dataset.data[item.dataIndex - 1];

                                if (previousValue === undefined) {
                                    return '';
                                }

                                return '+' + (currentValue - previousValue);
                            }
                        },
                    },
                },
            },
        };

        const myChart = new Chart(document.getElementById('shipping-chart'), config);

        let datasets = new DataSets(myChart);

        let nextOrderSeries = new Series({
            label: 'Next order',
            color: context => isStalled(context) ? '#8a2c2c' : '#4285f4',
            pointStyle: context => isStalled(context) ? 'triangle' : 'circle',
            pointRadius: context => isStalled(context) ? 6 : 3,
            pointRotation: 180,
        });

        let latestOrderSeries = new Series({label: 'Latest order', color: '#fbbc04'});
        let nextNonBlackOrder = new Series({label: 'Next non-black order', color: '#ff6d01',});

        datasets.addSeries('next', nextOrderSeries);
        datasets.addSeries('latest', latestOrderSeries);
        datasets.addSeries('next-non-black', nextNonBlackOrder);

        let firstShippedOrder = inputData[0][1];

        for (let i in inputData) {
            nextOrderSeries.addValue(inputData[i][0], inputData[i][1]);
            latestOrderSeries.addValue(inputData[i][0], inputData[i][2]);
            nextNonBlackOrder.addValue(inputData[i][0], inputData[i][3]);
        }

        const isStalled = function(context) {
            return context.type === 'data' && context.dataIndex > 0 && context.dataset.data[context.dataIndex] <= context.dataset.data[context.dataIndex - 1];
        };

        datasets.render();

        document.getElementById('myOrderNumber').onkeyup = function () {
            let value = this.value.match(/^\d+$/) ? parseInt(this.value, 10) : NaN;

            if (isNaN(value)) {
                document.cookie = 'myOrder=';

                datasets.removeSeries('my');

                datasets.render();

                return;
            }

            let myOrderSeries = datasets.getSeries('my');

            if (myOrderSeries === undefined) {
                myOrderSeries = new Series({label: 'My order', color: '#4ab04a', radius: 0, hoverRadius: 3})
                datasets.addSeries('my', myOrderSeries);
            } else {
                myOrderSeries.clearData();
            }

            let allDates;
            if (datasets.getSeries('prediction') !== undefined) {
                allDates = datasets.getDates();
            } else {
                allDates = datasets.getSeries('next').getDates();
            }

            allDates.forEach(function (date) {
                myOrderSeries.addValue(date, value);
            });

            document.cookie = 'myOrder=' + (isNaN(value) ? '' : value);

            datasets.render();
        };

        document.getElementById('myOrderNumber').value = document.cookie.split('; ').find(row => row.startsWith('myOrder='))?.split('=')[1];
        document.getElementById('myOrderNumber').dispatchEvent(new Event('keyup'));

        document.getElementById('type').onchange = function () {
            if (this.value === 'none') {
                datasets.removeSeries('prediction');

                datasets.render();

                document.getElementById('myOrderNumber').dispatchEvent(new Event('keyup'));

                return;
            }

            let historicalData = nextOrderSeries.getData();

            let allDates = nextOrderSeries.getDates();
            let lastDate = allDates[allDates.length - 1];

            let predictionSeries = datasets.getSeries('prediction');

            if (predictionSeries === undefined) {
                predictionSeries = new Series({label: 'Prediction', color: '#8f8f8f'});
                datasets.addSeries('prediction', predictionSeries);
            } else {
                predictionSeries.clearData();
            }

            let lastValue = historicalData[historicalData.length - 1].value;
            let counted = 0, perDay = 0, prevData;

            let historicalDataLimit = parseInt(document.getElementById('historicalDataLimit').value);

            if (!isNaN(historicalDataLimit) && historicalDataLimit > 0) {
                historicalData = historicalData.slice(-historicalDataLimit - 1);

                console.log(historicalData);
            }

            for (let i in historicalData) {
                if (prevData !== undefined) {
                    let daysPassed = Math.round((historicalData[i].date - prevData.date) / 1000 / 60 / 60 / 24);
                    let diff = historicalData[i].value - prevData.value;

                    if (this.value === 'max') {
                        perDay = Math.max(perDay, diff / daysPassed);
                    } else if (this.value === 'min') {
                        if (perDay === 0) {
                            perDay = diff / daysPassed;
                        }

                        if (diff / daysPassed > 0) {
                            perDay = Math.min(perDay, diff / daysPassed);
                        }
                    } else if (this.value === 'avg') {
                        perDay = ((perDay * counted) + diff) / (counted + daysPassed);
                        counted += daysPassed;
                    } else if (this.value === 'avg-optimistic') {
                        if (diff !== 0) {
                            perDay = ((perDay * counted) + diff) / (counted + daysPassed);
                            counted += daysPassed;
                        }
                    }
                }

                prevData = historicalData[i];
            }

            for (let i=0; i<7; ++i) {
                let date = new Date();
                date.setTime(lastDate.getTime());
                date.setDate(lastDate.getDate() + i * 7);

                predictionSeries.addValue(date, Math.round(lastValue + perDay * 7 * i));
            }

            datasets.render();

            document.getElementById('myOrderNumber').dispatchEvent(new Event('keyup'));
        };

        document.getElementById('historicalDataLimit').onchange = function () {
            document.getElementById('type').dispatchEvent(new Event('change'));
        };
    </script>
</body>
</html>
